// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO Customer (FirstName, LastName, Email)
VALUES (?, ?, ?)
RETURNING customerid, firstname, lastname, company, address, city, state, country, postalcode, phone, fax, email, supportrepid
`

type CreateCustomerParams struct {
	Firstname string `json:"firstname"`
	Lastname  string `json:"lastname"`
	Email     string `json:"email"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer, arg.Firstname, arg.Lastname, arg.Email)
	var i Customer
	err := row.Scan(
		&i.Customerid,
		&i.Firstname,
		&i.Lastname,
		&i.Company,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Postalcode,
		&i.Phone,
		&i.Fax,
		&i.Email,
		&i.Supportrepid,
	)
	return i, err
}

const getAlbum = `-- name: GetAlbum :one
SELECT albumid, title, artistid FROM Album
WHERE AlbumId=?
`

func (q *Queries) GetAlbum(ctx context.Context, albumid int64) (Album, error) {
	row := q.db.QueryRowContext(ctx, getAlbum, albumid)
	var i Album
	err := row.Scan(&i.Albumid, &i.Title, &i.Artistid)
	return i, err
}

const getAlbumsByArtist = `-- name: GetAlbumsByArtist :many
SELECT albumid, title, artistid FROM Album
WHERE ArtistId=?
`

func (q *Queries) GetAlbumsByArtist(ctx context.Context, artistid int64) ([]Album, error) {
	rows, err := q.db.QueryContext(ctx, getAlbumsByArtist, artistid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(&i.Albumid, &i.Title, &i.Artistid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAlbums = `-- name: GetAllAlbums :many
SELECT albumid, title, artistid FROM Album
`

func (q *Queries) GetAllAlbums(ctx context.Context) ([]Album, error) {
	rows, err := q.db.QueryContext(ctx, getAllAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(&i.Albumid, &i.Title, &i.Artistid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArtist = `-- name: GetArtist :one
SELECT artistid, name FROM Artist
WHERE ArtistId=?
`

func (q *Queries) GetArtist(ctx context.Context, artistid int64) (Artist, error) {
	row := q.db.QueryRowContext(ctx, getArtist, artistid)
	var i Artist
	err := row.Scan(&i.Artistid, &i.Name)
	return i, err
}

const getArtists = `-- name: GetArtists :many
SELECT artistid, name FROM Artist
`

func (q *Queries) GetArtists(ctx context.Context) ([]Artist, error) {
	rows, err := q.db.QueryContext(ctx, getArtists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artist
	for rows.Next() {
		var i Artist
		if err := rows.Scan(&i.Artistid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerInvoices = `-- name: GetCustomerInvoices :many
SELECT invoiceid, customerid, invoicedate, billingaddress, billingcity, billingstate, billingcountry, billingpostalcode, total
FROM Invoice
WHERE CustomerId=?
`

func (q *Queries) GetCustomerInvoices(ctx context.Context, customerid int64) ([]Invoice, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerInvoices, customerid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.Invoiceid,
			&i.Customerid,
			&i.Invoicedate,
			&i.Billingaddress,
			&i.Billingcity,
			&i.Billingstate,
			&i.Billingcountry,
			&i.Billingpostalcode,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomers = `-- name: GetCustomers :many
SELECT customerid, firstname, lastname, company, address, city, state, country, postalcode, phone, fax, email, supportrepid
FROM Customer
`

func (q *Queries) GetCustomers(ctx context.Context) ([]Customer, error) {
	rows, err := q.db.QueryContext(ctx, getCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Customer
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.Customerid,
			&i.Firstname,
			&i.Lastname,
			&i.Company,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.Postalcode,
			&i.Phone,
			&i.Fax,
			&i.Email,
			&i.Supportrepid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGenres = `-- name: GetGenres :many
SELECT genreid, name
FROM Genre
`

func (q *Queries) GetGenres(ctx context.Context) ([]Genre, error) {
	rows, err := q.db.QueryContext(ctx, getGenres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Genre
	for rows.Next() {
		var i Genre
		if err := rows.Scan(&i.Genreid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceLines = `-- name: GetInvoiceLines :many
SELECT invoicelineid, invoiceid, trackid, unitprice, quantity
FROM InvoiceLine
WHERE InvoiceId=?
`

func (q *Queries) GetInvoiceLines(ctx context.Context, invoiceid int64) ([]InvoiceLine, error) {
	rows, err := q.db.QueryContext(ctx, getInvoiceLines, invoiceid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InvoiceLine
	for rows.Next() {
		var i InvoiceLine
		if err := rows.Scan(
			&i.Invoicelineid,
			&i.Invoiceid,
			&i.Trackid,
			&i.Unitprice,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaTypes = `-- name: GetMediaTypes :many
SELECT mediatypeid, name 
FROM MediaType
`

func (q *Queries) GetMediaTypes(ctx context.Context) ([]MediaType, error) {
	rows, err := q.db.QueryContext(ctx, getMediaTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaType
	for rows.Next() {
		var i MediaType
		if err := rows.Scan(&i.Mediatypeid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistTracks = `-- name: GetPlaylistTracks :many
SELECT t.TrackId, t.Name, mt.Name 'Media Type', g.Name 'Genre',
        t.Composer, t.Milliseconds, t.Bytes, t.UnitPrice
FROM PlaylistTrack pt
JOIN Track t ON t.TrackId=pt.TrackId
JOIN MediaType mt ON mt.MediaTypeId=t.MediaTypeId
JOIN Genre g ON g.GenreId=t.GenreId
WHERE pt.PlaylistId=?
`

type GetPlaylistTracksRow struct {
	Trackid      int64   `json:"trackid"`
	Name         string  `json:"name"`
	MediaType    *string `json:"'media type'"`
	Genre        *string `json:"'genre'"`
	Composer     *string `json:"composer"`
	Milliseconds int64   `json:"milliseconds"`
	Bytes        *int64  `json:"bytes"`
	Unitprice    float32 `json:"unitprice"`
}

func (q *Queries) GetPlaylistTracks(ctx context.Context, playlistid int64) ([]GetPlaylistTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylistTracks, playlistid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaylistTracksRow
	for rows.Next() {
		var i GetPlaylistTracksRow
		if err := rows.Scan(
			&i.Trackid,
			&i.Name,
			&i.MediaType,
			&i.Genre,
			&i.Composer,
			&i.Milliseconds,
			&i.Bytes,
			&i.Unitprice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylists = `-- name: GetPlaylists :many
SELECT playlistid, name FROM Playlist
`

func (q *Queries) GetPlaylists(ctx context.Context) ([]Playlist, error) {
	rows, err := q.db.QueryContext(ctx, getPlaylists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(&i.Playlistid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTracksByAlbum = `-- name: GetTracksByAlbum :many
SELECT t.TrackId, t.Name, mt.Name 'Media Type', g.Name 'Genre',
        t.Composer, t.Milliseconds, t.Bytes, t.UnitPrice
FROM Track t
JOIN MediaType mt ON mt.MediaTypeId=t.MediaTypeId
JOIN Genre g ON g.GenreId=t.GenreId
WHERE t.AlbumId=?
`

type GetTracksByAlbumRow struct {
	Trackid      int64   `json:"trackid"`
	Name         string  `json:"name"`
	MediaType    *string `json:"'media type'"`
	Genre        *string `json:"'genre'"`
	Composer     *string `json:"composer"`
	Milliseconds int64   `json:"milliseconds"`
	Bytes        *int64  `json:"bytes"`
	Unitprice    float32 `json:"unitprice"`
}

func (q *Queries) GetTracksByAlbum(ctx context.Context, albumid *int64) ([]GetTracksByAlbumRow, error) {
	rows, err := q.db.QueryContext(ctx, getTracksByAlbum, albumid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTracksByAlbumRow
	for rows.Next() {
		var i GetTracksByAlbumRow
		if err := rows.Scan(
			&i.Trackid,
			&i.Name,
			&i.MediaType,
			&i.Genre,
			&i.Composer,
			&i.Milliseconds,
			&i.Bytes,
			&i.Unitprice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
